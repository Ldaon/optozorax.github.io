---
layout: post
title:  "Делаем идеально зацикленную гифку или как мне однажды пригодилась линейная алгебра"
tags: математика графика дерево-пифагора фракталы линейная-алгебра
permalink: linear-algebra
description: "Осторожно, много трафика и математики."
toc: false
image: 
vk: 
---

<style>
	video {
		max-width: 90%;
		display: block;
		margin-left: auto;
		margin-right: auto;
		border-radius: 5px;
	}
</style>

# Введение

Как вы знаете, я люблю рисовать фракталы, а ещё больше я люблю рисовать дерево Пифагора. Однажды я захотел сделать модную гифку, где камера будет двигаться таким образом, как будто мы, вращаясь и уменьшаясь, бесконечно погружаемся внутрь фрактала, то есть что-то такое:

![](/assets/interpolation/p3_4.2_45.gif)

В данной статьюе расскажу с чего я начал, на какие подводные камни наткнулся и как мне пригодилось взятие функции от матрицы - одна из сложнейших тем в универском курсе линейной алгебры.

# 2д камера

# Накидаю что-то, а потом это отсортирую

![](/assets/interpolation/p3_4.2_45_explanation.gif)

А вы спросите: как ты сделал эти гифки снизу? Если нарисовать дерево Пифагора ещё не очень сложно, как ты сделал это идеальное зацикливание в гифке, при переходе к внутренним элементам? Ответ: интерполяция систем координат!

Смотрим на гифки-ответы к нижним гифкам, и видим, что там показано объяснение как это строится, там есть две системы координат: начальная и конечная. Сейчас я буду показывать методы как постепенно переходить от одной системы координаты к другой: интерполяцию.

Первое что приходит на ум: интерполировать линейно каждый вектор и позицию системы координат. И это работает вот так:

![](/assets/interpolation/interpolation_linear.gif)

Но работать она будет не идеально, а именно вот так. То есть никакого плавного разворота, а довольно резкий в один момент. Это происходит из-за того, что производные в месте стыка последнего и первого кадра различаются. Увидеть это можно на следующей гифке.

![](https://video.twimg.com/tweet_video/D5qAdPyUIAACJw3.mp4)

Как видите, тут спираль прямая. В предыдущих гифках спираль идеально гладкая.

![](https://video.twimg.com/tweet_video/D5qA0kDUEAA_WkA.mp4)

Так же проблема линейной интерполяции в том, что она не сохраняет угол между осями координат, даже если вначале и в конце был прямой угол. В процессе угол между осями меняется.

![](/assets/interpolation/interpolation_linear_bad.gif)

Я подумал. Может можно сделать как-то глаже? Тогда я придумал интерполяцию на основе окружностей: переводим каждый направляющий вектор в полярные координаты, и уже полярные координаты интерполируем линейно, а вектор-радиус двигаем по окружности.

![](/assets/interpolation/interpolation_circular.gif)

Для этой интерполяции можно задавать: радиус окружности, направление вращения: по часовой, против часовой стрелки. Так же этот вид интерполяции по своему определению обязан сохранять угол между осями, если вначале и в конце они равны.

И он работает достаточно неплохо. Но всё-равно есть подергивания при стыке последнего и первого кадра.

![](https://video.twimg.com/tweet_video/D5qErYtV4AEy2kk.mp4)

Потом я придумал свою интерполяцию на основе сплайнов, изобрел методы для нахождения коэффициентов полиномов при помощи СЛАУ и умножения матриц. В общем занимался интересной математикой. Но итоговые сплайны работали хуже, чем интерполяция окружностями. Поэтому о них в другой раз.

А в итоге я понял, что никаких сплайнов и окружностей не нужно, можно просто возводить матрицу преобразований координат в дробную степень. Вы знали что так можно? Нет? Вот скриншот из Вольфрама:

![](https://pbs.twimg.com/media/D5qGmSTV4AE7dfU?format=png&name=360x360)

Интерполяция на основе этой идеи получилась настолько хороша, что она создает идеальный цикл! Именно при помощи этой интерполяции сделаны все гифки ниже. Я потом подробней расскажу как это работает, а пока смотрите её работу на примере:

![](/assets/interpolation/interpolation_matrix_power.gif)

Я обещал рассказать как работает интерполяция между двумя системами  координат на основе возведения матрицы в степень, и рассказ этот на  картинке. Быстренько накидал в латехе. Если будут вопросы - спрашивайте.

Система координат --- три вектора: \\(\mathbf{i}\\), \\(\mathbf{j}\\), \\(\mathbf{p}\\), где первые два --- оси, а третий --- положение системы координат.

Если задавать их при помощи матрицы в однородных координатах, то получится так:

\\[\mathbf{P} = \begin{pmatrix}
i_x & j_x & p_x \\\\\\\\
i_y & j_y & p_y \\\\\\\\
0 & 0 & 1 
\end{pmatrix}\\]

Тогда, чтобы получить точку из этой системы координат, надо умножить матрицу на вектор: \\(\mathbf{P} \cdot (x, y, 1)^T\\). Если же мы хотим преобразовать вектор направления, а не положения, то надо заменить \\(1\\) на \\(0\\).

Если мы хотим применить последовательно два преобразования координат: сначала \\(\mathbf{P_1}\\), затем \\(\mathbf{P_2}\\), то надо просто умножить их: \\(\mathbf{P_2} \cdot \mathbf{P_1} \cdot (x, y, 1)^T\\).

Окей, теперь наконец переходим к интерполяциии между двумя матрицами преобразования координат: 

\\[\mathbf{P_t} = (\mathbf{P_2} \cdot \mathbf{P_1}^{-1})^t \cdot \mathbf{P_1}, t \in [0, 1]\\]

Что очень похоже на формулу интерполяции между двумя числами:

\\[ c = (b-a)\cdot t + a\\]

А как возводить матрицу в дробную степень --- это уже совсем другая история! Благо нам с этим париться не надо, потому что есть уже готовые библиотеки, например: Eigen.

А пока я экспериментирую с интерполяцией между тремя системами координат! Да так, чтобы был плавный переход между последней и первой. Делаю при помощи возведения всех трёх матриц в степень. А вот выбор степени уже производится с помощью сплайнов с равными производными на концах.

![](/assets/interpolation/interpolation_three.gif)

Но мне не нравятся эти бугорки, надо придумать более хороший сплайн.

<script>
	var videoAttr = { 'autoplay': true, 'loop': true, 'mute': true, 'playsinline': true };
	var imgMP4s = Array.prototype.map.call(
	document.querySelectorAll('img[src*=".mp4"]'),
	function(img){

	var src = img.src;
	img.src = null;

	img.addEventListener('error', function(e){
	  console.log('MP4 in image not supported. Replacing with video', e); 
	  var video = document.createElement('video');

	  for (var key in videoAttr) { video.setAttribute(key, videoAttr[key]); }

	  for (
	    var imgAttr = img.attributes, 
	    len = imgAttr.length,
	    i = 0; 
	    i < len; 
	    i++
	  ) { 
	    video.setAttribute(imgAttr[i].name,  imgAttr[i].value); 
	  }

	  img.parentNode.insertBefore(video, img);
	  img.parentNode.removeChild(img);
	});

	img.src = src;
	});

	// thank you https://codepen.io/shshaw/pen/MOMezY !!!
	// https://calendar.perfplanet.com/2017/animated-gif-without-the-gif/
</script>